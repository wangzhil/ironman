Gof23： Gang of Four (四人帮)

分创建型：5种、结构型：7种、行为型：11种。

快速记忆：
创 公园,但见愁。(创造型：  工厂、原型、*** 单例、建造者、抽象工厂)
姐 想外租,世代装侨。(结构型： 享元、外观、组合、*** 适配器、代理、装饰者、桥接)
形 状折中模仿,戒备观测鸣笛。(行为型： 状态、责任链、中介、模板方法、访问、*** 解释器、备忘录、观察者、策略、命令、迭代)

结构型:  (最新特别理解：静态代理是继承并对引入目标对象的增强；装饰是继承和引入目标对象的组合；桥接是两个抽象方向的组合；适配器需要新增适配器方法，传入适配器，适配器引入被适配对象，执行被适配方法。)
    桥接模式：(理解1：相似模式,适配器模式;  弱弱分不清到底谁是谁。 桥接模式更多的是A和B两者互相搭配成一种全新结构，而适配器是A去适配B。
             理解2：两个维度的横向扩展，比如支付方式和支付渠道。一个维度A做实现,一个维度B做抽象接口继承，并将A维度抽象传入B维度内，结合使用。)
            (思考了下，想要用适配器模式来实现桥接的功能。想做两个抽象，会发现非常复杂，不如桥接。适配器更适合，一个方向固定，新增适配器方法，引入适配器)
    适配器模式：(理解1：通常A去适配B,一端方向固定，几乎无扩展,像电脑网线接口B，需要专门适配器A。B需要单独开一个适配的接口，方便进行适配。而桥接是不需要新增的)
            (理解2：适配器是新增方法去做功能的适配，达到其余类也能使用被适配类的功能。 桥接是不改变原始方法，将两个方向维度搭配成一个全新结构使用。)
    装饰模式：分两类A、B组合。A为超级父抽象类，B类继承自A，引入A形成套娃模式。区别于(桥接模式、 适配器模式、 代理模式)
    ![img.png](img.png)
            (理解1：装饰者和静态代理，都继承或者**实现目标对象，引入目标对象**。静态代理只是单纯的加强并且隐藏目标对象，装饰者是增强对象，并且拥有一种继承链的概念。)
            (理解2：装饰者、静态代理、适配器：装饰者和静态代理都是对继承、实现目标对象，对目标对象方法做增强。桥接，更多的是目标对象和源对象的各自方法的组合。)
    代理模式：* 静态代理：主要引入被代理对象，或者继承。重写方法或者新增相同方法添加代理逻辑。(引入对象可以使用set方法，或者构造器，spring和alibaba不建议构造器。)
            * 动态代理：区分为：cglib 和 javassist 和 jdk三种实现 (1)jdk：基于接口的 (2)cglib:基于类的 (3)javassist:java字节码实现
            (**JDK**： Proxy.newProxyInstance(ClassLoader, Interface, InvocationHandler),  使用lambda和分类使用
            Handler类，构造器传入被代理对象，面向接口的。method执行构造传入的对象invoke方法。
            Proxy代理类: getProxy(Object obj) 传入的为需要代理的对象。 方法内部调用Proxy.newProxyInstance()，业务端调用即可。)
            (**Cglib**： 步骤一：实现MethodInterceptor,做代理实现MethodProxy.invokeSuper(); 步骤二：Enhancer enhancer.superClass() 和 
            callBack(代理) 和create()用被代理对象接收.理解为先设置父级被代理类;再设置代理Interceptor，最后创建接收，执行方法。),
    外观模式： 将A、B、C、D到统一到外观类里面，相当于引入全部A、B、C、D变量，然后外观方法初始化变量，接着通过各种实现方法实现各变量功能。
            缺点：不符合开闭原则，修改麻烦。
            使用场景：类似controller调service；引入各种Dao调用一样，也类似网关。
            源码：tomcat作为web，会将请求信息封装成ServletRequest对象， 还有HttpServletRequest对象。实际是RequestFacade对象，聚合了Request对象。
            
